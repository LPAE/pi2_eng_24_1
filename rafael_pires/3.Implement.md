#### Arduino

O Arduino é uma plataforma eletrônica _open-source_, _baseada em hardware e software de fácil uso._

Os projetos de placas Arduino usam uma variedade de microprocessadores e controladores. As placas estão equipadas com conjuntos de pinos de _**input/output**_ digitais e analógicos que podem ser interligados a várias placas de expansão, _shields_, ou _protoboards_ e a outros circuitos. As placas apresentam interfaces de comunicação serial, incluindo o barramento serial universal (_USB_). Os microcontroladores podem ser programados usando as linguagens de programação **C** e **C++,** usando uma _API_ padrão que também é conhecida como **linguagem de programação Arduino**. O projeto Arduino fornece um ambiente de desenvolvimento integrado (_IDE_) e uma ferramenta de linha de comando.

A linguagem utilizada para programar o Arduino é uma variante do C++, incorporando métodos e funções específicas. Assim como o C++, é orientada a objetos, e o código escrito é chamado de &#39;_Sketches_&#39;.

A principal diferença entre C++ e a programação para Arduino está nas funções _setup_ e _loop_, que substituem a função _main_ comum em C++. A função _setup_ é usada para configurar os pinos e inicializar bibliotecas, e é executada apenas uma vez no início do programa. Já a função _loop_ é responsável por executar o código de forma contínua, funcionando de maneira semelhante a um _while_(1) no C.

#### _ESP-32_

O ESP-32 é um microcontrolador versátil e open-source que integra funcionalidades avançadas de hardware e software. Equipado com um processador de alto desempenho e conectividade _Wi-Fi_ e _Bluetooth._ O microcontrolador possui múltiplos pinos de input/output digitais e analógicos, que permitem a conexão com sensores, atuadores e outros dispositivos eletrônicos. Além disso, o ESP-32 oferece várias interfaces de comunicação, como _UART_, _SPI_ e _I2C_, e pode ser programado utilizando linguagens de programação como C e C++, com suporte a _frameworks_ como _ESP-IDF_ (Espressif IoT Development Framework) e Arduino.

![ESP32-CAM](./fig/fig8.png)

#### Estrutura do _firmware_

_Firmware_ é o _software_ embutido em dispositivos eletrônicos que controla o hardware e fornece funcionalidades básicas. Ele inclui código de controle para gerenciar o hardware, _drivers_ e em alguns casos, um sistema operacional de baixo nível. No contexto dos microcontroladores o _firmware_ é o _software_ que é carregado diretamente no microcontrolador para controlar e gerenciar seu funcionamento. Ele inclui o código que define as operações básicas do microcontrolador, como a execução de tarefas, a interação com periféricos (sensores, atuadores, etc.), e a comunicação com outros dispositivos.

imagem

A firmware de um ESP-32 é o software que é carregado no microcontrolador e é responsável por realizar as operações desejadas pelo usuário. A formação da firmware de um ESP-32 envolve a integração de vários componentes, que incluem o código da aplicação, as bibliotecas e drivers necessários para interagir com o hardware, como sensores, atuadores, módulos de comunicação (Wi-Fi, Bluetooth), e outras interfaces e  ambiente de desenvolvimento.

### **Testes para entendimento no Arduino**

Para aprofundar _o entendimento no Arduino foram realizados quatro testes, o Blink, Serial,_

#### _Blink_

```cpp
void setup() {
  pinMode(2, OUTPUT);
}
void loop() {
  digitalWrite(2, HIGH);
  delay(500);
  digitalWrite(2, LOW);
  delay(500); 
}
```

Primeiro o um dos códigos mais simples, seu objetivo é fazer o led interno do ESP-32 piscar, primeiro na setup o pinMode, define o pino 2 como saída digital, no loop esse mesmo pino é definido como HIGH, assim acendendo o led interno, depois há um delay de 500ms até que o pino 2 seja definido como LOW seguido por outro delay de 500ms, assim fazendo o led apagar, com isso o o led ficara acesso por meio segundo e apagado por meio segundo.

_Serial_

AnalogReadSerial

```cpp
void setup() {
  // initialize serial communication at 9600 bits per second:
  Serial.begin(9600);
}
void loop() {
  Serial.println(A0);
  delay(1);        // delay in between reads for stability
}
```

```cpp
uint32_t chipId = 0;

void setup() {
  Serial.begin(115200);
}

void loop() {
  for (int i = 0; i < 17; i = i + 8) {
    chipId |= ((ESP.getEfuseMac() >> (40 - i)) & 0xff) << i;
  }

  Serial.printf("ESP32 Chip model = %s Rev %d\n", ESP.getChipModel(), ESP.getChipRevision());
  Serial.printf("This chip has %d cores\n", ESP.getChipCores());
  Serial.print("Chip ID: ");
  Serial.println(chipId);

  delay(3000);
}
```

####   

Sensor de Velocidade LM393 com Arduino. **Arduino e cia**. Disponível em: [https://www.arduinoecia.com.br/sensor-de-velocidade-lm393-arduino/](https://www.arduinoecia.com.br/sensor-de-velocidade-lm393-arduino/). Acesso em: 20 mar. 2024.

Introdução ao Arduino. **Arduino**. Disponível em: https://www.arduino.cc/en/Guide/Introduction. Acesso em: 1 set. 2024.

Arduino. Disponível em: [https://en.wikipedia.org/wiki/Arduino](https://en.wikipedia.org/wiki/Arduino). Acesso em: 1 set. 2024.

Referência de Arduino. **Arduino**. Disponível em: [https://www.arduino.cc/reference/en](https://www.arduino.cc/reference/en). Acesso em: 1 set. 2024.

Controle de Motor DC com PWM e Arduino Uno. **Maker hero**. Disponível em: [https://www.makerhero.com/blog/controle-motor-dc-pwm-arduino-uno/](https://www.makerhero.com/blog/controle-motor-dc-pwm-arduino-uno/). Acesso em: 1 set. 2024.